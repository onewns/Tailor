Node.js 란?

![img](https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_dVkLf_1488258076674/1488258785174_image.png)

**Node.js** 는 **서버사이드 자바스크립트**이며 구글의 자바스크립트 엔진인 **V8**을 기반으로 구성된 일종의 소프트웨어 시스템입니다.

이벤트 기반으로 개발이 가능하며 Non-Blocking I/O를 지원하기 때문에 **비동기식 프로그래밍**이 가능합니다. 이 때문에 I/O 부하가 심한 대규모 서비스를 개발하기 적합하다고 할 수 있습니다. 또한 자바스크립트의 표준라이브러리 프로젝트인 CommonJS의 스펙을 따르고 있습니다.

사실 노드에서 처음 등장한 것과 같이 느껴지는 비동기 프로그래밍 모델은 최근 등장한 새로운 개념은 아닙니다. 실제로 다른 프로그래밍 언어에서 비슷한 환경을 찾아볼 수 있는데, 대표적으로는 Python의 Twisted, Perl의 Perl Object Environment, C언어의 libevent, Ruby의 EventMachine 등이 있습니다.



### Node.js 를 사용하는 서비스들

------



노드는 다른 언어들 만큼 등장한 지 오래되지 않았음에도, 이를 실제로 적용한 기업들의 사례가 늘어나고 있습니다. 노드의 실제 동작 방식을 알아보기에 앞서 노드를 사용하는 서비스 몇 개에 대해서 간단히 알아보겠습니다.

![img](https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_dVkLf_1488258076674/5c53d1788039519e3387069d142f4bf3de7eb7ab12fda3633b06b7915d2fe304.png)

**Walmart**

세계적으로 유명한 대형마트인 월마트에서도 자신들의 모바일 앱의 백엔드 서비스를 위해서 노드를 활용하고 있습니다. 주로 하이브리드 앱 스타일로 구성하고, 기능 대부분은 노드를 통해 서버 사이드에서 작동하도록 했습니다.

**LinkedIn**

유명한 SNS 서비스 중 하나인 LinkedIn은 자사의 모바일 웹 관련 서비스를 위해서 노드와 mongoDB를 사용하고 있습니다. LinkedIn은 노드 사용의 대표적인 사례로 자신들의 메인 서비스를 Ruby On Rails로 돌릴 때는 15대의 서버에서 15개의 인스턴스로 돌리다가, 노드로 개발한 뒤에는 두 배에 달하는 트래픽을 단지 4개의 인스턴스만으로도 운영이 가능하다고 했습니다. 또한 LinkedIn의 인턴십을 수행하던 사람들이 24시간동안의 핵데이HackDay를 통해 노드를 이용하여 VNC 클라이언트를 구현한 재미있는 케이스도 있습니다.



**Cloud9 IDE**

Cloud9 IDE는 가장 널리 쓰이고 있는 웹기반 통합개발환경으로서 웹 브라우저에서 노드 기반의 애플리케이션을 쉽게 개발할 수 있도록 해주는 서비스입니다. 노드로 웹 애플리케이션을 개발할 수 있는 환경을 제공하지만, 그 서비스 자체도 노드를 이용하여 개발되어 있습니다. 사용자와 직접 상호 작용하는 프론트엔드 부분을 HTML5/CSS/Javascript로 제작함과 동시에 서버에서 실질적으로 작업을 수행하는 백엔드에서도 노드를 사용하여 하나의 언어로 전체 서비스를 개발하였습니다. 



이벤트 기반 비동기 방식

﻿노드가 뛰어난 성능을 발휘할 수 있는 이유는 크게 **비동기 이벤트 기반 아키텍처**와 **구글의 V8 자바스크립트 엔진**을 이용했기 때문이라고 말할 수 있습니다. 



### 쓰레드 기반 vs 비동기 이벤트 기반

------

지금까지 대부분의 애플리케이션은 Blocking I/O를 사용하였고, 이 때문에 멀티 쓰레드를 사용할 수밖에 없었습니다. 멀티 쓰레드는 개발자 입장에서는 직관적이고 멀티 태스킹을 위해서는 어쩔 수 없는 선택이기도 하지만, 네트워크에서 동시에 대규모 요청을 동시에 처리하는 데에는 부적절합니다. 멀티 쓰레드에 대해서는 아래에서 좀 더 자세히 다뤄보도록 하겠습니다.

### Blocking I/O

------

일반적인 애플리케이션들은 대부분 Blocking I/O를 사용합니다. Blocking I/O에 대해 자세히 설명하자면, "**하나의 프로세스가 어떤 자원을 사용하고자 할 때 그 자원을 다른 프로세스가 점유하고 있다면, 그 프로세스가 그 자원의 사용을 끝마칠 때까지 기다려야 한다는 것**"을 의미합니다. 

![img](https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_dNOma_1488263111120/1488263625769_image.png)

먼저 애플리케이션이 운영체제의 커널에게 파일을 읽기 위해 시스템 콜이라는 형태로 요청을 보냅니다. 커널은 파일을 읽기 위한 동작을 수행하기 시작하고 애플리케이션은 커널이 파일을 다 읽을 때까지 기다려야 합니다. 일반적으로 이 상태를 애플리케이션이 **Blocked** 되었다고 표현하며 이 시간 동안 실제로 애플리케이션은 아무것도 하지 않는 상태가 됩니다.



### 멀티 쓰레드

------

일반적으로 하나의 프로세스가 하나의 요청에 대해 대응하고 그 일을 처리하게 되는데, 만약 웹서버와 같이 다수의 요청이 들어오게 된다면 멀티 쓰레드라는 개념을 사용할 수 밖에 없게 됩니다.

멀티 쓰레드는 말 그대로 쓰레드 여러 개가 동시에 실행되어 요청을 처리한다는 개념입니다. 이것은 CPU의 시분할이라는 개념으로 설명될 수 있습니다. 시분할 개념은 하나의 CPU를 여러 프로세스 또는 쓰레드가 시간을 나누어 동작하도록 함으로써 마치 CPU를 공유하여 사용하는 것과 같은 효과를 냅니다. 

![img](https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_dNOma_1488263111120/1488263996541_image.png)

그림의 첫 번째 경우는 시분할을 이용하지 않고 **싱글 쓰레드**로 요청을 처리할 때의 모습입니다. 먼저 들어 온 요청을 먼저 처리하고 이 요청에 대한 처리가 끝날 때까지 기다린 후에 다음 요청을 처리하는 식입니다. 따라서 먼저 요청한 작업이 먼저 응답을 받을 수 있습니다.

두 번째 경우는 **단순한 프로세스 스케줄링을 적용**한 경우로 특정 쓰레드가 일정 시간만 CPU를 사용할 수 있도록 되어 있습니다. 이 경우 프로세스 C가 가장 늦게 요청을 했음에도 불구하고 가장 먼저 응답을 받을 수도 있음을 보여주고 있습니다.

**CPU를 사용할 수 있는 시간이 더 적게 설정**된 세 번째 경우에도 마찬가지로 먼저 요청이 온 A보다 B가 먼저 작업을 마치고 응답을 할 수도 있는 모습을 보여주고 있습니다. 



### 쓰레드로 인해 발생하는 문제

------

살펴본 바와 같이 멀티 쓰레드를 통해 복수의 요청으로 인해 발생하는 공유 문제는 해결할 수 있었습니다.

CPU 사용에 대해 스케줄링을 통해 멀티 쓰레딩을 하더라도 하나의 CPU를 다수의 쓰레드가 사용하고자 한다면, 결국 CPU 자체도 하나의 자원이기 때문에 여러 쓰레드들이 CPU를 점유하기 위해 기다릴 수밖에 없다는 점은 근본적인 문제로써 내버려 두도록 합시다. 그렇다면 쓰레드 기반으로 동작할 때 발생하는 실질적인 문제점은 무엇일까요?

먼저 Blocking I/O 자체가 발생시키는 쓰레드 지연에 대한 문제입니다. 더 쉽게 이야기하면 **I/O 요청을 하고 응답이 올 때까지 아무것도 하지 않고 시간을 낭비**한다는 문제가 발생한다는 것입니다.

다음으로는 스케줄링을 위한 처리 시간과 **문맥 전환**(Context switch) 비용이 발생한다는 점입니다. 다시 말해 쓰레드를 분배하여 사용하기 위해 사용하는 스케줄링 그 자체도 CPU를 이용한 연산이 필요한 작업이고, 쓰레드 간의 전환을 위해서는 전환하기 직전의 쓰레드를 나중에 복귀시킬 때를 대비하여 그 상태를 저장해두어야 하는데, 이 또한 CPU를 이용한 연산이 필요한 작업입니다. 따라서 쓰레드가 많아질수록 문맥전환에 따른 성능 저하가 발생할 수 있는데, 이 때문에 쓰레드들을 별도로 관리하거나, 더 작은 단위로 쪼개어 VM 등으로 실제 쓰레드로 분배하는 방식 같은 대안이 등장하고 있습니다. 이러한 방식들은 문맥 전환에 드는 시간이 네이티브 CPU 쓰레드를 사용하는 것보다 더 적습니다.



### 싱글 쓰레드와 이벤트 기반의 비동기 I/O 처리

------

노드는 이러한 문제들을 **싱글 쓰레드**와 **이벤트 기반의 비동기 I/O 처리로 해결**하고 그 성능을 끌어올릴 수 있도록 하는 비동기 프로그래밍 모델을 제공해주고 있습니다.

싱글 쓰레드를 가진 노드는 I/O 작업이 시작되면 I/O 작업 처리에 대한 응답을 기다리지 않고, **바로 다음 작업을 실행**해버립니다. 대신 I/O 작업이 종료되면 이벤트를 발생시키고, 이 이벤트는 해당 프로세스의 이벤트 큐에 등록되게 됩니다. 노드로 개발된 프로세스는 이 이벤트 큐에 등록된 새로운 이벤트를 감지하여, 해당 이벤트 시 수행하여야 할 작업을 실행하게 됩니다. 



### 이벤트 루프

------

이벤트 루프(Event Loop)라는 것은 작업을 요청하면서 그 작업이 완료되었을 때 어떤 작업을 진행할지에 대한 콜백 함수를 지정하여 **동작이 완료되었을 때 해당 콜백 함수를 실행되는 방식의 동작 방식**을 말합니다.

만약 클라이언트가 **웹 서버에 HTTP 형식으로 요청**하게 되면 서버에서는 **이벤트 루프가 계속 돌고 있다가** 이를 감지하고 **알맞은 작업을 워커 쓰레드를 생성하여 실행**합니다. 이때 이벤트 루프는 해당 워커 쓰레드가 작업을 마친 뒤 그 결과와 함께 응답할 때까지 기다리는 것이 아니라 바로 루프로 복귀하여 다른 요청을 기다리게 됩니다.

다시 말해 이벤트 루프는 **어떤 요청이 발생하면 그 작업에 대해 쓰레드 실행**만을 일으킬 뿐입니다. 이후 작업을 할당받았던 해당 쓰레드가 모든 작업을 마치면 미리 전달받은 콜백 함수를 실행하도록 이벤트 루프로 응답하게 되며 이벤트 루프는 이것을 실행하여 클라이언트에게 결과를 응답해줍니다. 

![img](https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_dNOma_1488263111120/1488269479578_image.png)

Node.js 의 특징

지금까지 노드의 가장 큰 특징 중 하나인 이벤트 기반의 **비동기 처리 방식**에 대해 알아보았습니다. 하지만 이것만으로는 노드에게 매력을 덜 느끼는 사람도 있을 거라고 생각합니다. 하지만 노드는 이벤트 기반의 비동기 처리 방식이라는 특징 외에도 다양한 매력을 가지고 있는 프로그래밍 언어입니다. 특히 자바스크립트를 기반으로 하고 있다는 점과 이벤트 기반의 프로그래밍 모델, 확장성 있는 모듈 구조는 확실히 노드를 더욱더 매력적으로 만들어주는 요소들입니다. 



### 자바스크립트 기반

------

몇 번에 걸쳐 설명했다시피 노드는 **자바스크립트를 기반**으로 하고 있습니다. 자바스크립트는 가장 저평가된 언어라고 할 정도로 사실 그 면면을 살펴보면 아주 훌륭한 프로그래밍 언어입니다. 이러한 자바스크립트를 기반으로 개발할 수 있다는 것 자체도 장점이지만, 개발과 관리의 측면에서 또 다른 장점에 대해서도 이야기할 수 있을 것 같습니다.

기존의 웹 애플리케이션에서 프론트엔드를 구성하는 대부분이 자바스크립트였던 것을 생각해봅시다. 노드를 사용한다는 것은 이제 **백엔드도 자바스크립트를 이용하여 개발**할 수 있다는 것입니다.

다시 말해 **프론트엔드와 백엔드가 자바스크립트라는 하나의 언어로 통일**된다는 것이죠. 이것은 단순히 개발 언어의 통일만을 의미하지 않습니다. 하나의 개발 언어를 사용하게 되면 프론트엔드와 백엔드가 좀 더 긴밀한 구조로 설계될 수 있고, 같은 프로그래머가 양쪽 모두를 개발할 수 있습니다. 따라서 개발 단계에서나 유지보수 단계에서 시간, 인력을 줄일 수 있으며 이로 인해 코드 통합이 쉬워지게 됩니다. JSON과 같은 공통 데이터 포맷도 프론트엔드와 백엔드 사이에서 쉽게 사용될 수 있습니다.





### 이벤트 기반의 프로그래밍 모델

------



노드의 이벤트 기반 비동기 처리 방식이 가장 큰 특징이자 장점이라고 설명했었는데, 왜 다시 한 번 장점으로 이벤트 기반의 프로그래밍 모델을 언급하는 것일까요?

이번에는 **이벤트 기반의 비동기 처리 방식으로 인해 발생하는 성능 향상에 대한 장점이 아닌 프로그래밍 모델 자체**에 대해 언급하고자 합니다.

노드를 처음 접하는 수강자분들은 이벤트 기반의 프로그래밍 모델이 처음일 수도 있겠지만 사실 근 몇 년 동안 프론트엔드 개발에서는 **jQuery**라는 자바스크립트 라이브러리가 널리 쓰이고 있었습니다. 바로 이 jQuery가 이벤트 기반의 비동기 처리 방식으로 개발할 수 있도록 해주는데, 이러한 jQuery에 익숙한 개발자들에게는 이벤트 기반의 프로그래밍 모델을 가지고 있는 노드는 정말 매력적인 백엔드 개발 언어임이 틀림없습니다.



### NPM을 통한 다양한 확장 모듈들

------

노드는 확장성이 뛰어난 모듈 구조를 가지고 있는데, 이를 통해 기본적으로 제공하는 모듈 이외의 다양한 확장 모듈을 설치하여 사용할 수 있습니다. 게다가 **NPM**이라는 **설치 관리자**를 통해 확장 모듈을 쉽게 설치할 수 있게 되어 있습니다. NPM을 통한 다양한 기능을 가진 확장 모듈들은 노드의 보급에 큰 영향을 끼쳤으며, 앞으로도 훌륭한 확장 모듈들이 쏟아져 나올 것으로 보입니다. **NPM**에 대해서는 6장에서 자세히 다루도록 하겠습니다. 

**노드 표준 라이브러리(Node standard library)**

실질적으로 V8과 연결되어 특정 기능들을 수행할 수 있도록 도와주는 자바스크립트 기본 라이브러리입니다. 자바스크립트 언어로 작성되었으며, 이를 통해 노드 바인딩과 연결됩니다.

**노드 바인딩(Node bindings)**

C/C++로 구성된 시스템 바인딩 레이어입니다. C/C++ 로 작성된 라이브러리를 자바스크립트에서 사용할 수 있도록 결합하는 핵심 요소입니다. 소켓, http 등의 통신 기능이 제공되지만, DOM에 관한 기능은 제공되고 있지 않습니다. 소켓이나 http 등에 대한 노드 바인딩이 노드 표준 라이브러리와의 인터페이스 역할을 합니다. 

**V8 엔진**

V8 자바스크립트 엔진은 구글에서 개발된 오픈소스 JIT 가상머신 형식의 자바스크립트 엔진입니다. 1강 자바스크립트 엔진 파트에서도 설명되었습니다. 구글 크롬 브라우저에 내장되어 있지만 독립적으로 실행 가능하며, C++로 작성된 응용 프로그램의 일부로 작동할 수도 있습니다. 노드는 이 엔진을 이용하여 자바스크립트로 개발된 노드 애플리케이션을 동작시킵니다.

**쓰레드 풀(thread pool)**

쓰레드풀은 libeio라는 비동기 I/O 라이브러리로 구성되어 있습니다. 즉, 파일 관련 작업을 수행한다고 보면 됩니다. 이벤트 기반이 모든 게 비동기로 동작하는 C언어용 I/O 라이브러리입니다. 파일 관련 작업이란, read, write, open, close, stat, unlink, fdatasync, mknod, readdir 등의 작업들을 일컬으며, 모두 비동기로 처리합니다. 노드에서의 비동기 입출력 작업들은 모두 이 라이브러리로 동작한다고 생각하면 됩니다. Node.js도 싱글 쓰레드만 사용하는 것이 아니라 내부적으로 멀티 쓰레드 풀을 사용하기는 합니다. 

**이벤트 루프(event loop)**

이벤트 루프는 libev를 이용하여 구성되어 있습니다. 다양한 기능을 가진 고성능 이벤트 루프 라이브러리로, libevent라는 라이브러리와 유사합니다. 노드의 이벤트 루프가 이것으로 구성되어 있습니다.





# Node.js 설치

노드는 현존하는 대부분의 시스템을 지원하고 있습니다. 노드는 오픈 소스 프로젝트이기 때문에 설치하는 방법도 다양합니다. **소스 코드를 직접 다운로드** 받아 설치하거나, 운영체제에서 기본적으로 제공되는 **패키지 매니저**나, 또는 써드파티로 개발된 **소프트웨어 패키지 매니저**를 통해 설치할 수도 있습니다. 또한 윈도우와 맥을 위한 공식 인스톨러도 출시되어 설치가 더더 쉬워졌습니다.



### 노드 설치 방법

------

노드를 설치하는 방법은 크게 3가지로 나눌 수 있습니다. 하지만 우리 강의에서는 1장에서 말한 것과 같이 **구름IDE**를 사용할 것이기 때문에, 아래와 같은 별도의 설치 절차가 필요 없습니다. 그래도 IDE를 사용하지 않을 때는 어떻게 노드를 설치하는지 간단하게 설명해보겠습니다.

아래 그림처럼 **소스 코드를 다운로드 받아 직접 빌드**하여 설치하는 경우, 필요한 라이브러리를 설치하는 것이 우선입니다. 이후에 소스 코드를 직접 다운로드 받아 gcc를 이용하여 컴파일 및 빌드를 하고 어디서든 노드 명령어를 이용할 수 있게 환경 변수에 경로를 설정합니다. 이 방법은 우분투와 맥에서 가능합니다.

![img](https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_OLoQJ_1488421119139/1488421170455_image.png)

다른 방법은 패키지 매니저를 이용한 설치 방법으로서 우분투와 맥에서 사용 가능한 방법입니다. 우분투에는 **「apt-get」**이라는 명령어를 이용하여 쉽게 소프트웨어를 설치하고 관리할 수 있는데, 우분투에서 기본적으로 제공하는 소프트웨어 저장소에는 노드가 없으므로 노드 설치와 관련된 정보를 가진 저장소를 추가해주고 이를 이용하여 설치하는 방식입니다. 맥과 윈도우의 경우에는 써드파티에서 만든 소프트웨어 패키지 매니저가 있는데, 이를 이용하여 우분투와 유사하게 설치할 수 있습니다. 

마지막 방법은 노드에서 공식적으로 제공하는 인스톨러를 이용하여 설치하는 방법입니다. 아주 간단한 방법으로 **[공식 홈페이지](https://nodejs.org/ko/download/)**에서 인스톨러를 다운로드 받아 실행하여 설치하기만 하면 됩니다. 윈도우, 맥을 지원하고 있습니다. 단, 이렇게 인스톨러를 이용해 설치하게 되면 Node.js의 여러 버전은 관리할 수가 없기 때문에 불편합니다. 또한 이미 노드를 설치했다면 깔끔히 삭제하는 것이 어렵습니다. 따라서 IDE를 이용하지 않고 직접 설치하고 싶으신 분들은 인스톨러 대신 Node.js의 버전별로 관리/설치할 수 있는 NVM을 이용하는 것이 바람직합니다.

NVM은 Node Version Manager의 약자로, Node.js의 다양한 릴리스 버전을 관리할 수 있어 가장 많이 사용됩니다. apt 패키지 매니저 대신 사용하는 툴입니다.

구름IDE를 사용하면 이렇게 설치할 필요가 없으니, 직접 설치하려면 이런 식으로 진행하는구나 정도로만 알아두시면 됩니다.

![img](https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_OLoQJ_1488421119139/a7f6d69cd59b74b5250ce45bbbfd76e69a165d7204ba348af0a4ec2fdbc44fa7.png)

노드에는 LTS 버전과 Current 버전이 있는데 차이는 다음과 같습니다.

**LTS 버전**

- 장기적으로 지원이 제공되는 안정적인 버전
- 안정성과 보안성에 초점을 두어 개발함

**Current 버전**

- 업데이트가 잦음
- 가장 최신의 버전이므로 불안정하고 숨겨져 있는 버그가 많음
- 추가 기능 개발과 기존 API의 기능 개선을 우선함